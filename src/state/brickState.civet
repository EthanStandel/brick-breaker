{ createSignal } from "solid-js"
{ screenState } from "./screenState.civet"
{ memo } from "../utils/memo.civet"

initalBrickCount := 50
brickBorder := 3
maxBricksPerRow := => 5
brickLeftSpacing := => screenState.gameContainerSize() / (maxBricksPerRow() + 2)
brickTop := => screenState.gameContainerSize() / 20
brickWidth := => brickLeftSpacing()
brickLeft := => brickLeftSpacing()
brickHeight := => brickTop()

getInitialBricks := => ((Array.from { length: initalBrickCount }).map ((_, i) => ({
  health: createSignal (Math.floor(Math.random() * 4))
  id: i
})))
[bricks, setBricks] := createSignal getInitialBricks()
[bricksLeft, setBricksLeft] := createSignal(bricks().filter(({ health: [health] }) => !!health()).length)

getTopOfBrick := (id: number) =>
  brickHeight() * Math.floor(id / maxBricksPerRow())
getBottomOfBrick := (id: number) =>
  getTopOfBrick(id) + brickHeight()
getLeftOfBrick := (id: number) =>
  id % maxBricksPerRow() * brickWidth()
getRightOfBrick := (id: number) =>
  getLeftOfBrick(id) + brickWidth()

getBrickDimensions := memo((id: number) => ({
  top: getTopOfBrick(id) + brickTop()
  bottom: getBottomOfBrick(id) + brickTop()
  left: getLeftOfBrick(id) + brickLeft()
  right: getRightOfBrick(id) + brickLeft()
}))

export brickState := {
  bricks
  setBricks
  bricksLeft
  setBricksLeft
  brickBorder
  brickLeftSpacing
  brickTop
  brickWidth
  brickLeft
  brickHeight
  maxBricksPerRow
  getTopOfBrick
  getBottomOfBrick
  getLeftOfBrick
  getRightOfBrick
  getBrickDimensions
  reset: =>
    setBricks getInitialBricks()
    setBricksLeft bricks().filter(({ health: [health] }) => !!health()).length
}