{ type Component, createSignal, Show, onCleanup, For } from "solid-js"

// utils
docEvent := <K extends keyof DocumentEventMap>(
  type: K,
  listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions
) =>
  document.addEventListener type, listener
  onCleanup (=> document.removeEventListener type, listener)

onFrame := (callback: () => (boolean | void)) =>
  onFrame := =>
    cancel := callback()
    if !cancel
      requestAnimationFrame onFrame
  requestAnimationFrame onFrame

// player state
paddleHeight := window.innerHeight / 100
paddleWidth := window.innerWidth / 10
paddleRadius := paddleWidth / 2
minPaddleCenter := paddleRadius
maxPaddleCenter := => window.innerWidth - paddleRadius
[paddleCenter, setPaddleCenter] := createSignal window.innerWidth / 2
// ball state
ballWidth := paddleHeight * 2
ballRadius := ballWidth / 2
initialVelocity := => (Math.max window.innerHeight, window.innerWidth) / 2
totalBallVelocity := initialVelocity
[ballAttached, setBallAttached] := createSignal true
[ballY, setBallY] := createSignal window.innerHeight - paddleHeight - ballRadius
[ballX, setBallX] := createSignal window.innerWidth / 2
[ballVelocityY, setBallVelocityY] := createSignal 0
[ballVelocityX, setBallVelocityX] := createSignal 0
// game state
[score, setScore] := createSignal 0
[gameState, setGameState] := createSignal<"PLAYING" | "PAUSED" | "LOSER" | "WINNER"> "PLAYING"
gameStopped := => gameState() is not "PLAYING"
togglePause := =>
  setGameState do
    if gameState() is "PLAYING"
      "PAUSED" 
    else if gameState() is "PAUSED"
      "PLAYING" 
    else gameState()
// brick state
initalBrickCount := 50
brickBorder := 4
brickLeftSpacing := 50
brickTop := 75
brickWidth := window.innerWidth / 5
brickLeft := (window.innerWidth - brickLeftSpacing * 2) % brickWidth / 2 + brickLeftSpacing
brickHeight := window.innerHeight / 25
maxBricksPerRow := Math.floor((window.innerWidth - brickLeftSpacing * 2) / brickWidth)
getInitialBricks := => ((Array.from { length: initalBrickCount }).map ((_, i) => ({
  health: createSignal (Math.floor(Math.random() * 4))
  id: i
})))
[bricks, setBricks] := createSignal getInitialBricks()
[bricksLeft, setBricksLeft] := createSignal(bricks().filter(({ health: [health] }) => !!health()).length)

resetGame := =>
  setTimeout (=>
    setGameState "PLAYING"
    setBallAttached true
    setBallY window.innerHeight - paddleHeight - ballRadius
    setBallX window.innerWidth / 2
    setBallVelocityY 0
    setBallVelocityX 0
    setPaddleCenter window.innerWidth / 2
    setScore 0
    setBricks getInitialBricks()
    setBricksLeft bricks().filter(({ health: [health] }) => !!health()).length
  ), 0
pauseOrReset := =>
  if gameState() is "LOSER" or gameState() is "WINNER"
    resetGame()
  else
    togglePause()

isMakingContactWithPaddle := =>
  ballX() > paddleCenter() - paddleRadius and ballX() < paddleCenter() + paddleRadius

launch := =>
  setBallAttached false
  setBallVelocityX(1 + totalBallVelocity() * (ballX() - paddleCenter()) / paddleRadius)
  setBallVelocityY(-1 + (-totalBallVelocity() + Math.abs(ballVelocityX())))

App: Component := =>

  <For each=bricks()>
    ({ id, health: [health] }) =>
      <Brick {id} {health()}>
  <Ball>
  <Player>
  <GameStatus>
  <GithubLink>

getTopOfBrick := (id: number) =>
  brickHeight * Math.floor(id / maxBricksPerRow)
getBottomOfBrick := (id: number) =>
  getTopOfBrick(id) + brickHeight
getLeftOfBrick := (id: number) =>
  id % maxBricksPerRow * brickWidth
getRightOfBrick := (id: number) =>
  getLeftOfBrick(id) + brickWidth

Brick: Component<{ id: number; health: number; }> := (props) =>
  y := getTopOfBrick props.id
  x := getLeftOfBrick props.id
  <div style={do
    display := if props.health is 0 then "none" else "flex"
    borderPattern := if props.health > 1 then "solid" else "dotted"
    {
      position: "fixed"
      top: `${brickTop}px`
      left: `${brickLeft}px`
      transform: `translateX(${x}px) translateY(${y}px)`
      width: `${brickWidth - brickBorder * 2}px`
      height: `${brickHeight - brickBorder * 2}px`
      border: `${brickBorder}px ${borderPattern} white`
      display
      "justify-content": "center"
      "align-items": "center"
      color: "white"
      "font-size": "${brickHeight / 2}px"
      background: "black"
      "z-index": 3
    }
  }>{props.health}

Ball: Component := =>
  lastFrameTime .= new Date().getTime()
  onFrame (=>
    now := new Date().getTime()
    duration := (now - lastFrameTime) / 1000
    
    lastFrameTime = now
    if ballAttached() or gameStopped() return
    nextY := ballY() + ballVelocityY() * duration
    nextX := ballX() + ballVelocityX() * duration

    contact := bricks().some (({ id, health: [health, setHealth] }) =>
      brick := {
        top: getTopOfBrick(id) + brickTop
        bottom: getBottomOfBrick(id) + brickTop
        left: getLeftOfBrick(id) + brickLeft
        right: getRightOfBrick(id) + brickLeft
      }
      contact := health() is not 0 
        and nextY + ballRadius > brick.top
        and nextY - ballRadius < brick.bottom
        and nextX + ballRadius > brick.left
        and nextX - ballRadius < brick.right
      if (contact)
        setScore score() + 1
        setHealth health() - 1
        if (health() is 0)
          setBricksLeft bricksLeft() - 1
          if (bricksLeft() is 0)
            setGameState "WINNER"
            return
        stillInContact := nextY + ballRadius > brick.top
          and nextY - ballRadius < brick.bottom
          and ballX() + ballRadius > brick.left
          and ballX() - ballRadius < brick.right
        if stillInContact
          setBallVelocityY -ballVelocityY()
        else
          setBallVelocityX -ballVelocityX()
      contact
    )

    if contact return

    if nextY < ballRadius
      setBallVelocityY -ballVelocityY()
      setBallY ballRadius
    else if nextY > window.innerHeight - paddleHeight - ballRadius and isMakingContactWithPaddle()
      launch()
    else if nextY > window.innerHeight - ballRadius
      setBallY window.innerHeight - ballRadius
      setGameState "LOSER"
    else
      setBallY nextY

    if nextX > window.innerWidth - ballRadius
      setBallVelocityX -ballVelocityX()
      setBallX window.innerWidth - ballRadius
    else if nextX < ballRadius
      setBallVelocityX -ballVelocityX()
      setBallX ballRadius
    else
      setBallX nextX
    return
  )

  docEvent "click", (=> if isMakingContactWithPaddle() and ballAttached() then launch())

  <div style={
    height: `${ballWidth}px`
    width: `${ballWidth}px`
    background: "white"
    "border-radius": "50%"
    top: 0
    left: 0
    position: "fixed"
    "will-change": "transform"
    "box-shadow": `${-ballVelocityX() / 100}px ${-ballVelocityY() / 100}px 20px -20px white`
    transform: `translateY(calc(${ballY()}px - 50%)) translateX(calc(${ballX()}px - 50%))`
  }>
    <div style={do
      trailSize := if ballAttached() then 0 else ballWidth * 2
      {
        background: "linear-gradient(270deg, white, transparent)"
        position: "absolute"
        top: "50%"
        left: "50%"
        transform: do
          radians := Math.atan2(ballVelocityY(), ballVelocityX())
          trail := trailSize / 2 - ballWidth / 2
          ```
            translate(
              calc(-50% + ${trail * -Math.cos(radians)}px),
              calc(-50% + ${trail * -Math.sin(radians)}px)
            )
            rotate(${radians}rad)
          ```
        height: `${ballWidth}px`
        width: `${trailSize}px`
        "border-radius": `${ballRadius}px`
        "z-index": -1
      }
    }>

Player := => 
  movePlayer := (x: number) =>
    if gameStopped() return
    setPaddleCenter do
      if x < minPaddleCenter then minPaddleCenter
      else if x > maxPaddleCenter() then maxPaddleCenter()
      else x

  docEvent "touchmove", (({ touches }) => 
    movePlayer touches[0].clientX
  )

  docEvent "mousemove", (({ clientX }) => 
    movePlayer clientX
  )

  <div style={
    height: `${paddleHeight}px`
    width: `${paddleWidth}px`
    background: "white"
    position: "fixed"
    left: 0
    bottom: 0
    "pointer-events": "none"
    "will-change": "transform"
    transform: `translateX(calc(${paddleCenter()}px - 50%))`
  }>

GameStatus := =>
  docEvent "keydown", (({ key }) => if key is "Escape" then pauseOrReset())

  <div style={
    position: "fixed"
    top: "25px"
    left: "25px"
    color: "white"
    "font-size": "50px"
    "text-shadow": "0 0 10px black"
    "user-select": "none"
  }>{score()}
  <Show when={gameStopped()}>
    <div style={
      position: "fixed"
      top: "50%"
      left: "50%"
      transform: "translate(-50%, -50%)"
      color: "white"
      "font-size": "min(20vh, 20vw)"
      "text-shadow": "0 0 10px black"
      "user-select": "none"
      "z-index": 5
    }>{gameState()}
  <button 
    style={
      all: "unset"
      cursor: "pointer"
      position: "fixed"
      top: "25px"
      right: "25px"
    }
    onClick=pauseOrReset>
    <svg width="50" height="50">
      <Show when={gameState() is not "PLAYING"}>
        <polygon points="5,0 45,25 5,50" fill="white" />
      <Show when={gameState() is "PLAYING"}>
        <rect x="0" y="0" width="20" height="50" fill="white" />
        <rect x="30" y="00" width="20" height="50" fill="white" />

GithubLink := =>
  <a href="https://github.com/EthanStandel/brick-breaker/blob/main/src/App.civet"
    style={
      position: "fixed"
      bottom: "25px"
      right: "25px"
    }
    target="_blank"
    rel="noopener noreferrer">
    <img width="50" height="50" src="/github.svg">

export default App